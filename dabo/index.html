<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boldog Újévet!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@800&display=swap" rel="stylesheet">
    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        /* Chroma Key (Green/Black Screen Removal) */
        .chroma-key-green {
            filter: url(#chroma-key-green-filter);
        }

        .chroma-key-black {
            mix-blend-mode: screen;
        }

        .meme-gif {
            position: absolute;
            pointer-events: none;
            display: none;
        }

        .meme-full {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .meme-side {
            height: 40%;
            top: 30%;
            object-fit: contain;
        }

        .meme-left {
            left: 0;
        }

        .meme-right {
            right: 0;
        }

        #gameBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        #memeLayerBehind {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #memeLayerAbove {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #memeLayerEnemies {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }

        #gameCanvas {
            position: relative;
            z-index: 3;
            background: transparent !important;
        }

        .game-score,
        .health-display,
        .game-ui,
        .menu-overlay {
            z-index: 4002;
        }

        /* Game UI Styles */
        .game-score {
            position: static;
            font-size: 2rem;
            color: #ffd700;
            font-weight: bold;
            z-index: 4002;
            text-shadow: 2px 2px 0 #000;
        }

        .menu-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #ffd700;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            color: white;
            z-index: 5000;
            display: none;
            min-width: 300px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu-overlay h1 {
            color: #ffd700;
            margin-top: 0;
            text-transform: uppercase;
        }

        .menu-btn {
            display: block;
            width: 100%;
            padding: 1rem;
            margin: 10px 0;
            background: #00bcd4;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            text-transform: uppercase;
        }

        .menu-btn:hover {
            background: #00acc1;
        }

        .menu-btn.shop {
            background: #9c27b0;
        }

        .menu-btn.exit {
            background: #f44336;
        }

        .menu-btn.back {
            background: #777;
        }

        .shop-item {
            background: #333;
            border: 2px solid #555;
            padding: 10px;
            margin: 10px 0;
            border-radius: 10px;
            text-align: left;
        }

        .shop-item button {
            width: 100%;
            padding: 10px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .shop-item button:disabled {
            background: #555;
            cursor: not-allowed;
            color: #888;
        }

        /* Original Styles */
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: 'Outfit', sans-serif;
        }

        /* Game Overlay Styles */
        .game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 4000;
            /* Below viruses but above everything else */
            display: none;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .game-ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 4001;
            display: flex;
            gap: 10px;
        }

        .finish-btn {
            background: #ff0000;
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
        }

        .ingame-shop-btn {
            background: #9c27b0;
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
        }

        .level2-btn {
            background: #ff9800;
            color: white;
            border: 2px solid white;
            padding: 10px 20px;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: none;
            /* Shown after boss kill */
        }

        .level2-btn.centered {
            position: fixed;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            padding: 20px 40px;
            z-index: 5000;
        }

        .wasd-tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            z-index: 2;
            display: none;
            opacity: 0.9;
            pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
        }

        .health-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 4002;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 2px 2px 0 #000;
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
        }

        .volume-display {
            position: absolute;
            top: 60px;
            left: 20px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 4002;
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 2px 2px 0 #000;
        }

        .volume-slider {
            width: 150px;
            cursor: pointer;
        }

        .health-bar-fill {
            height: 100%;
            background: #00ff00;
            width: 100%;
            transition: width 0.2s;
        }

        .start-game-btn {
            margin-top: 1rem;
            background: #00bcd4;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #008ba3;
        }

        .start-game-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        body {
            background-image: url('marcigany.gif');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            z-index: 10;
            width: 95%;
            max-width: 1600px;
            min-height: 90vh;
            justify-content: flex-start;
        }

        .message {
            font-size: 6rem;
            /* Much bigger */
            font-weight: 800;
            color: white;
            text-align: center;
            text-shadow:
                4px 4px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000;
            animation: pulse 2s infinite;
            margin-top: 2rem;
            /* Moved down a bit */
            margin-bottom: 1rem;
            flex-shrink: 0;
            line-height: 1;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3rem;
            width: 95%;
            max-width: 1500px;
            align-items: start;
            margin: 0 auto;
        }

        /* Video Styles */
        .video-container {
            width: 100%;
            display: flex;
            justify-content: flex-end;
            align-items: flex-start;
        }

        video {
            display: block;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 75vh;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        /* Slot Machine Styles */
        .slot-machine-container {
            transform: scale(1);
            width: 100%;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-radius: 20px;
            border: 4px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }

        .global-money-display {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 1.8rem;
            font-weight: bold;
            white-space: nowrap;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            z-index: 100;
            position: absolute;
            left: calc(100% + 20px);
            top: 0;
        }

        .desktop-only {
            display: block;
        }

        .dabonium-mobile-container {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }

        .interaction-column {
            width: 400px;
            justify-self: start;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            align-items: center;
        }

        .dabo-wars-container {
            background: rgba(0, 0, 0, 0.86);
            padding: 1.5rem;
            border-radius: 20px;
            border: 4px solid #00bcd4;
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 100%;
            box-sizing: border-box;
        }

        .dabo-man-container {
            background: rgba(0, 0, 0, 0.86);
            padding: 1.5rem;
            border-radius: 20px;
            border: 4px solid #ff5722;
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 100%;
            box-sizing: border-box;
        }

        .game-title {
            font-size: 2rem;
            font-weight: 900;
            color: #00bcd4;
            text-transform: uppercase;
            text-shadow: 0 2px 0 #008ba3;
            text-align: center;
        }

        .slot-title {
            font-size: 2rem;
            font-weight: 900;
            color: #ffd700;
            text-transform: uppercase;
            text-shadow: 0 2px 0 #b8860b;
            margin-bottom: 0px;
            /* Removed margin */
            text-align: center;
            line-height: 1;
            /* Tighter line height */
        }

        .slot-window {
            display: flex;
            gap: 10px;
            background: #333;
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #555;
            overflow: hidden;
        }

        .reel {
            width: 80px;
            height: 80px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            border: 3px solid #000;
            position: relative;
        }

        .reel-strip {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            /* Transition set dynamically in JS */
        }

        .reel-strip img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            display: block;
        }

        .spin-btn {
            background: linear-gradient(to bottom, #ffd700, #b8860b);
            border: none;
            padding: 0.8rem 2.5rem;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
            font-weight: 800;
            color: #4a3c00;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow:
                0 4px 0 #8b6508,
                0 5px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.1s;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
            min-width: 150px;
            /* Fixed width to prevent jumping when text changes */
        }

        .spin-btn:active {
            transform: translateY(4px);
            box-shadow:
                0 0 0 #8b6508,
                0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .spin-btn:disabled {
            /* We don't use disabled anymore for SKIP logic, but keeping style just in case */
            filter: grayscale(0.8);
            cursor: not-allowed;
        }

        /* Scam Overlay */
        .scam-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .scam-modal {
            background: #222;
            border: 2px solid #ffd700;
            padding: 2rem;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            color: white;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.2);
            text-align: center;
            overflow-y: auto;
            max-height: 90vh;
        }

        .scam-title {
            font-size: 3rem;
            color: #ffd700;
            margin: 0 0 1rem 0;
            text-transform: uppercase;
        }

        .scam-subtitle {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            color: #ddd;
        }

        .form-group {
            margin-bottom: 1rem;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #ffd700;
        }

        .form-group input {
            width: 100%;
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid #555;
            background: #333;
            color: white;
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            box-sizing: border-box;
        }

        .scam-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .claim-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            flex: 1;
            min-width: 150px;
            transition: transform 0.1s;
        }

        .claim-btn:active {
            transform: scale(0.95);
        }

        .refuse-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            flex: 1;
            min-width: 150px;
            transition: transform 0.1s;
        }

        .refuse-btn:active {
            transform: scale(0.95);
        }

        /* Hekas Overlay */
        .hekas-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .hekas-overlay img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Win Overlay */
        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .win-text {
            font-size: 8rem;
            font-weight: 900;
            text-align: center;
            line-height: 1.1;
            background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: rainbow 2s linear infinite, shake 0.5s ease-in-out infinite;
            text-transform: uppercase;
        }

        .close-btn {
            margin-top: 2rem;
            padding: 1rem 2rem;
            font-size: 1.5rem;
            background: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
        }

        @keyframes rainbow {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: rotate(-5deg);
            }

            50% {
                transform: rotate(5deg);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        @media (max-width: 1200px) {
            .message {
                font-size: 4rem;
            }

            .main-content {
                gap: 1rem;
            }
        }

        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
                justify-items: center;
                gap: 2rem;
            }

            .video-container {
                justify-content: center;
            }

            video {
                max-height: 50vh;
                width: 100%;
                max-width: 600px;
            }

            .global-money-display {
                position: static;
                width: 100%;
                margin: 0 0 1rem 0;
                text-align: center;
            }

            .slot-machine-container,
            .dabo-wars-container,
            .dabo-man-container {
                transform: scale(1);
                width: 100%;
                max-width: 450px;
            }

            .interaction-column {
                min-width: auto;
                width: 100%;
                max-width: 100%;
                gap: 1.5rem;
                flex: 1 1 auto;
            }

            .global-money-display {
                position: static;
                width: 100%;
                margin-bottom: 0.5rem;
                text-align: center;
                box-sizing: border-box;
            }

            .message {
                font-size: 2.5rem;
                margin-top: 1rem;
            }

            .desktop-only {
                display: none;
            }

            .dabonium-mobile-container {
                display: block;
            }
        }

        @media (max-height: 700px) {
            .message {
                font-size: 2.5rem;
            }

            .content-wrapper {
                gap: 1rem;
            }
        }

        /* Virus Popup Styles */
        .popup {
            position: absolute;
            width: 280px;
            z-index: 5000;
            /* On top of everything */
        }

        .style-classic {
            background-color: #c0c0c0;
            border: 2px outset white;
            box-shadow: 10px 10px 5px rgba(0, 0, 0, 0.5);
            font-family: Arial, sans-serif;
        }

        .style-classic .popup-header {
            background: linear-gradient(90deg, darkblue, blue);
            color: white;
            padding: 3px;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .style-classic .popup-close {
            background-color: #c0c0c0;
            color: black;
            border: 1px outset white;
            width: 16px;
            height: 16px;
            text-align: center;
            line-height: 14px;
            font-size: 12px;
            cursor: pointer;
        }

        .style-terminal {
            background-color: black;
            border: 2px solid lime;
            color: lime;
            font-family: 'Consolas', monospace;
        }

        .style-terminal .popup-header {
            background: lime;
            color: black;
            padding: 5px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .style-terminal .popup-close {
            background: black;
            color: lime;
            border: 1px solid black;
            cursor: pointer;
        }

        .style-alert {
            background-color: #ffcccc;
            border: 4px solid red;
            color: red;
            font-family: Arial, sans-serif;
        }

        .style-alert .popup-header {
            background: red;
            color: white;
            padding: 5px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .style-alert .popup-close {
            background: white;
            color: red;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            cursor: pointer;
        }

        .style-flashy {
            background-color: yellow;
            border: 3px dashed magenta;
            font-family: 'Comic Sans MS', sans-serif;
        }

        .style-flashy .popup-header {
            background: magenta;
            color: yellow;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            padding: 2px;
        }

        .style-flashy .popup-close {
            background: yellow;
            color: magenta;
            border: 1px solid magenta;
            cursor: pointer;
        }

        .popup-content {
            padding: 10px;
            text-align: center;
            color: black;
        }

        .style-terminal .popup-content {
            color: lime;
        }

        .style-alert .popup-content {
            color: red;
        }

        .style-flashy .popup-content {
            color: blue;
        }

        .popup img {
            max-width: 100%;
            display: block;
            margin: 0 auto;
        }

        /* Game UI & Level Buttons */
        .top-right-gui {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex !important;
            flex-direction: row !important;
            flex-wrap: nowrap !important;
            align-items: center !important;
            gap: 20px;
            z-index: 4002;
        }

        .game-buttons {
            display: flex !important;
            flex-direction: row !important;
            flex-wrap: nowrap !important;
            gap: 10px;
            align-items: center;
        }

        .game-score {
            font-size: 1.8rem;
            color: #ffd700;
            font-weight: 800;
            text-shadow: 2px 2px 0 #000;
            margin: 0;
            font-family: 'Outfit', sans-serif;
            white-space: nowrap;
        }

        .level-btn {
            background: linear-gradient(to bottom, #00bcd4, #0097a7);
            border: none;
            padding: 0.6rem 1rem;
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 800;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #006064;
            transition: all 0.1s;
        }

        @media (max-width: 600px) {
            .top-right-gui {
                top: 10px;
                right: 10px;
                gap: 5px;
                flex-direction: column;
                align-items: flex-end;
            }

            .game-score {
                font-size: 1.5rem;
            }

            .level-btn,
            .ingame-shop-btn,
            .finish-btn {
                padding: 5px 10px;
                font-size: 0.9rem;
            }

            .game-buttons {
                gap: 5px;
            }
        }

        /* Reset Button */
        .reset-btn {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(220, 53, 69, 0.6);
            color: white;
            border: 1px solid #dc3545;
            padding: 5px 10px;
            font-size: 0.7rem;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            font-family: 'Outfit', sans-serif;
            text-transform: uppercase;
        }

        .reset-btn:hover {
            background: rgba(220, 53, 69, 1);
        }

        @media screen and (max-width: 900px) {
            .reset-btn {
                position: static;
                margin: 20px auto;
                display: block;
                width: 100px;
                text-align: center;
            }
        }

        /* Entry Overlay */
        #entryOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
            text-align: center;
            transition: opacity 0.5s ease, visibility 0.5s;
        }

        #entryOverlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .entry-title {
            font-size: 4rem;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            margin-bottom: 2rem;
            font-family: 'Outfit', sans-serif;
        }

        .entry-ok-btn {
            background: linear-gradient(to bottom, #ffd700, #b8860b);
            border: none;
            padding: 1.5rem 4rem;
            font-family: 'Outfit', sans-serif;
            font-size: 2rem;
            font-weight: 800;
            color: #4a3c00;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #8b6508;
            transition: all 0.1s;
        }

        .entry-ok-btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #8b6508;
        }

        @media (max-width: 768px) {
            .entry-title {
                font-size: 2.5rem;
                padding: 0 1rem;
            }
        }
    </style>
</head>

<body>
    <!-- SVG Chroma Key Filters -->
    <svg style="position: absolute; width: 0; height: 0; overflow: hidden;" xmlns="http://www.w3.org/2000/svg">
        <filter id="chroma-key-green-filter" color-interpolation-filters="sRGB">
            <feColorMatrix type="matrix" values="
                1 0 0 0 0
                0 1 0 0 0
                0 0 1 0 0
                1.5 -3 1.5 1 0
            " />
            <feComponentTransfer>
                <feFuncA type="table" tableValues="0 1" />
            </feComponentTransfer>
        </filter>
    </svg>
    <div id="entryOverlay">
        <div class="entry-title">EZT SZÁMÍTÓN NÉZD!</div>
        <button class="entry-ok-btn" onclick="closeEntryOverlay()">OK</button>
    </div>

    <div class="content-wrapper">
        <div class="message">
            Boldog újévet!
        </div>

        <div class="main-content">
            <!-- Video Section -->
            <div class="video-container">
                <video id="radicsVideo" autoplay loop playsinline controls
                    onerror="console.error('Video error:', this.src)">
                    <source src="./radics.mp4" type="video/mp4">
                    A böngésződ nem támogatja a videó lejátszását.
                </video>
            </div>

            <!-- Interaction Column (Slot + Game) -->
            <div class="interaction-column">
                <!-- Mobile Dabonium Display -->
                <div class="dabonium-mobile-container">
                    Dabonium: <span id="globalMoneyValueMobile">0</span>
                </div>

                <!-- Slot Machine Section -->
                <div class="slot-machine-container">
                    <div class="slot-title" style="margin-bottom: 0; line-height: 1;">SZERENCSEJÁTÉK!!!!!!!!</div>
                    <div
                        style="font-size: 1rem; color: #fff; margin-bottom: 0px; text-shadow: 1px 1px 0 #000; font-weight: bold; line-height: 1.2;">
                        Nyeremény: 100 Dabonium</div>
                    <div
                        style="font-size: 0.7rem; color: #ccc; margin-bottom: 5px; text-shadow: 1px 1px 0 #000; line-height: 1.2;">
                        és 1.000.000 robux</div>
                    <div class="slot-window">
                        <div class="reel" id="reel1">
                            <div class="reel-strip"></div>
                        </div>
                        <div class="reel" id="reel2">
                            <div class="reel-strip"></div>
                        </div>
                        <div class="reel" id="reel3">
                            <div class="reel-strip"></div>
                        </div>
                    </div>
                    <button class="spin-btn" id="spinBtn">SPIN</button>
                    <div class="global-money-display desktop-only">Dabonium: <span id="globalMoneyValue">0</span></div>
                </div>

                <!-- Dabo Wars 2 Section -->
                <div class="dabo-wars-container">
                    <div class="game-title">Dabo Wars 2</div>
                    <button class="start-game-btn" id="startGameBtn">START</button>
                </div>

                <!-- Dabo-Man 67 Section -->
                <div class="dabo-man-container">
                    <div class="game-title" style="color: #ff5722; text-shadow: 0 2px 0 #bf360c;">Dabo-Man 67</div>
                    <button class="start-game-btn" onclick="startPacmanGame()"
                        style="background: #ff5722; box-shadow: 0 4px 0 #bf360c;">START</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scam Form Overlay -->
    <div class="scam-overlay" id="scamOverlay">
        <div class="scam-modal">
            <h1 class="scam-title">NYERTÉL!</h1>
            <p class="scam-subtitle">nyertél 1.000.000.000 robuxot, hogy átvedd írd le ezeket az adataid:</p>

            <div class="form-group">
                <label>1. Kártyaszám</label>
                <input type="text" placeholder="XXXX XXXX XXXX XXXX">
            </div>
            <div class="form-group">
                <label>2. Lejárati dátum</label>
                <input type="text" placeholder="HH/ÉÉ">
            </div>
            <div class="form-group">
                <label>3. CV kód</label>
                <input type="text" placeholder="XXX">
            </div>
            <div class="form-group">
                <label>4. Facebook jelszavad</label>
                <input type="password" placeholder="********">
            </div>
            <div class="form-group">
                <label>5. Név</label>
                <input type="text" placeholder="Teljes név">
            </div>

            <div class="scam-buttons">
                <button class="claim-btn" id="claimBtn">Robux igénylése</button>
                <button class="refuse-btn" id="refuseBtn">Nem szeretném megadni az adataim</button>
            </div>
        </div>
    </div>

    <!-- Hekas Overlay -->
    <div class="hekas-overlay" id="hekasOverlay">
        <img src="./hekas.gif" alt="HEKAS" onerror="console.error('Hekas load failed')">
    </div>

    <!-- Game Overlay -->
    <div class="game-overlay" id="gameOverlay">
        <div id="memeLayerBehind"></div>
        <div id="gameBackground"></div>
        <div id="memeLayerAbove"></div>
        <div id="memeLayerEnemies"></div>
        <canvas id="gameCanvas"></canvas>
        <img id="wasdTutorial" src="./wasd.png" class="wasd-tutorial" alt="WASD Control Tutorial"
            onerror="console.error('WASD tutorial load failed')">
        <div class="top-right-gui">
            <div class="game-buttons">
                <button class="level-btn" id="level1SelectBtn" onclick="startGame()">1.</button>
                <button class="level-btn" id="level2SelectBtn" onclick="startLevel2()"
                    style="display: none;">2.</button>
                <button class="ingame-shop-btn" id="ingameShopBtn" onclick="openShopIngame()">BOLT</button>
                <button class="finish-btn" id="finishGameBtn">BEFEJEZÉS</button>
            </div>
            <div class="game-score">
                Dabonium: <span id="scoreDisplay" style="cursor: pointer; text-decoration: underline;"
                    onclick="cheatScore()" title="Kattints a csaláshoz!">0</span>
            </div>
        </div>

        <div class="health-display">
            Élet:
            <div class="health-bar-container">
                <div class="health-bar-fill" id="healthBarFill"></div>
            </div>
        </div>

        <div class="volume-display">
            Hangerő:
            <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.01" value="0.4">
        </div>



        <!-- Level Win Menu -->
        <div id="levelWinMenu" class="menu-overlay">
            <h1 id="winStatusText">PÁLYA TELJESÍTVE</h1>
            <p id="winRewardText">KAPTÁL 1000 DABONIUMOT!</p>
            <button class="menu-btn next" id="nextLevelBtn">Következő Pálya</button>
            <button class="menu-btn shop" id="winShopBtn">Bolt</button>
            <button class="menu-btn exit" id="winExitBtn">Kilépés</button>
        </div>

        <!-- Post Game Menu -->
        <div id="postGameMenu" class="menu-overlay">
            <h1>Játék Vége</h1>
            <button class="menu-btn" id="restartBtn">Újrakezdés</button>
            <button class="menu-btn shop" id="shopBtn">Bolt</button>
            <button class="menu-btn exit" onclick="document.getElementById('finishGameBtn').click()">Kilépés</button>
        </div>

        <!-- Shop Menu -->
        <div id="shopMenu" class="menu-overlay">
            <h1>Bolt</h1>
            <p>Dabonium: <span id="shopMoneyDisplay" style="cursor: pointer; text-decoration: underline;"
                    onclick="cheatScore()">0</span></p>
            <div class="shop-item">
                <button id="upg1Btn" onclick="buyUpgrade(1)">50 Dabonium - Automáta (14/mp)</button>
            </div>
            <div class="shop-item">
                <button id="upg2Btn" onclick="buyUpgrade(2)">70 Dabonium - Gyorstüzelés (20/mp + Dupla)</button>
            </div>
            <div class="shop-item">
                <button id="upg3Btn" onclick="buyUpgrade(3)">150 Dabonium - Tükörhajó</button>
            </div>
            <button class="menu-btn back" onclick="closeShop()">Vissza</button>
        </div>
    </div>

    <!-- Virus Container -->
    <div id="virus-container"></div>

    <!-- Win Overlay -->
    <div class="win-overlay" id="winOverlay">
        <div class="win-text">BUZI VAGY</div>
        <button class="close-btn" onclick="document.getElementById('winOverlay').style.display='none'">X</button>
    </div>

    <!-- Sounds -->
    <audio id="bgMusic" src="./zene.mp3" preload="auto" loop
        onerror="console.error('zene.mp3 load failed', this.src)"></audio>
    <audio id="bgMusic2" src="./zene2.mp3" preload="auto"
        onerror="console.error('zene2.mp3 load failed', this.src)"></audio>
    <audio id="spinSound" src="./spin.mp3" preload="auto"
        onerror="console.warn('spin.mp3 missing - sound disabled')"></audio>
    <audio id="winSound" src="./win.mp3" preload="auto"
        onerror="console.warn('win.mp3 missing - sound disabled')"></audio>
    <audio id="btnSound" src="./button_sound1.ogg" preload="auto"
        onerror="console.warn('button_sound1.ogg missing - sound disabled')"></audio>

    <link rel="preload" as="image" href="./meme_fekete.gif">

    <script>
        function closeEntryOverlay() {
            const overlay = document.getElementById('entryOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        // Redirect to add trailing slash if missing (fixes relative paths on GitHub Pages)
        if (window.location.pathname.endsWith('/dabo')) {
            window.location.replace(window.location.href + '/');
        }

        // Global variables for audio and slot UI elements
        let bgMusic, bgMusic2, spinSound, winSound, btnSound, volumeSlider;
        let scamOverlay, hekasOverlay, claimBtn, refuseBtn, virusContainer;
        let spinBtn, reelStrips, winOverlay, globalMoneyValue;
        let images = ['./1.png', './2.gif', './3.png', './4.png'];

        // Game state variables moved to global scope
        let gameRunning = false;
        let isPaused = false;
        let currentLevel = 1;
        let level2Phase = 0;
        let score = 0;
        let autoFireLevel = 0;
        let hasMirrorShip = false;
        let isLoopRunning = false;
        let unlockedLevel2 = false;

        function saveGameState() {
            localStorage.setItem('daboMoney', score.toString());
            localStorage.setItem('daboAutoFire', autoFireLevel.toString());
            localStorage.setItem('daboMirrorShip', hasMirrorShip.toString());
            localStorage.setItem('daboUnlockedLevel2', unlockedLevel2.toString());
        }

        function initAudio() {
            // Initial load of state from localStorage
            const savedScore = localStorage.getItem('daboMoney');
            if (savedScore !== null) score = parseInt(savedScore);

            const savedAutoFire = localStorage.getItem('daboAutoFire');
            if (savedAutoFire !== null) autoFireLevel = parseInt(savedAutoFire);

            const savedMirror = localStorage.getItem('daboMirrorShip');
            if (savedMirror !== null) hasMirrorShip = (savedMirror === 'true');

            const savedLevel2 = localStorage.getItem('daboUnlockedLevel2');
            if (savedLevel2 !== null) unlockedLevel2 = (savedLevel2 === 'true');

            updateShopUI();

            // Browsers often need a user gesture to resume the AudioContext or play.
            if (bgMusic && bgMusic.paused && gameRunning) {
                bgMusic.play().catch(() => { });
            }
            if (bgMusic2 && bgMusic2.paused && typeof currentLevel !== 'undefined' && currentLevel === 2) {
                bgMusic2.play().catch(() => { });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize global variables
            bgMusic = document.getElementById('bgMusic');
            bgMusic2 = document.getElementById('bgMusic2');
            spinSound = document.getElementById('spinSound');
            winSound = document.getElementById('winSound');
            btnSound = document.getElementById('btnSound');
            volumeSlider = document.getElementById('volumeSlider');
            scamOverlay = document.getElementById('scamOverlay');
            hekasOverlay = document.getElementById('hekasOverlay');
            claimBtn = document.getElementById('claimBtn');
            refuseBtn = document.getElementById('refuseBtn');
            virusContainer = document.getElementById('virus-container');

            spinBtn = document.getElementById('spinBtn');
            winOverlay = document.getElementById('winOverlay');
            reelStrips = [
                document.querySelector('#reel1 .reel-strip'),
                document.querySelector('#reel2 .reel-strip'),
                document.querySelector('#reel3 .reel-strip')
            ];
            globalMoneyValue = document.getElementById('globalMoneyValue');
            const globalMoneyValueMobile = document.getElementById('globalMoneyValueMobile');

            // Sync function for both displays
            const updateGlobalMoney = (val) => {
                if (globalMoneyValue) globalMoneyValue.textContent = val;
                if (globalMoneyValueMobile) globalMoneyValueMobile.textContent = val;
                saveGameState();
            };

            // Load initial state
            const savedScore = localStorage.getItem('daboMoney');
            if (savedScore !== null) score = parseInt(savedScore);

            const savedAutoFire = localStorage.getItem('daboAutoFire');
            if (savedAutoFire !== null) autoFireLevel = parseInt(savedAutoFire);

            const savedMirror = localStorage.getItem('daboMirrorShip');
            if (savedMirror !== null) hasMirrorShip = (savedMirror === 'true');

            const savedLevel2 = localStorage.getItem('daboUnlockedLevel2');
            if (savedLevel2 !== null) unlockedLevel2 = (savedLevel2 === 'true');

            updateGlobalMoney(score);

            // Add global click listener for audio "unlocking"
            document.body.addEventListener('mousedown', initAudio, { once: true });
            document.body.addEventListener('touchstart', initAudio, { once: true });
            document.body.addEventListener('keydown', initAudio, { once: true });

            // Global Button Sound Listener
            document.body.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    // Check if inside virus container (heuristic: virus window usually has specific class, 
                    // or we check if the button is the 'X' button inside a virus div)
                    // The virus creation logic creates divs with class 'virus-window' and close buttons inside header.
                    if (e.target.closest('.virus-window')) {
                        return; // Skip sound for virus close
                    }

                    if (btnSound) {
                        btnSound.currentTime = 0;
                        btnSound.play().catch(err => console.log('Btn sound play failed', err));
                    }
                }
            });

            // Video autoplay logic
            const video = document.getElementById('radicsVideo');
            if (video) {
                video.volume = 1.0;
                video.play().catch(error => {
                    console.log("Az automatikus lejátszás hanggal nem sikerült:", error);
                });
            }

            // Initial volume setup
            if (bgMusic) bgMusic.volume = 0.4;
            if (bgMusic2) bgMusic2.volume = 0.4;

            if (volumeSlider) {
                volumeSlider.addEventListener('input', (e) => {
                    const vol = e.target.value;
                    if (bgMusic) bgMusic.volume = vol;
                    if (bgMusic2) bgMusic2.volume = vol;
                });
            }

            const iconHeight = 80;
            const numIcons = images.length;
            const loops = 12;

            // Initialize Reels
            if (reelStrips[0]) {
                reelStrips.forEach(strip => {
                    let html = '';
                    for (let i = 0; i < loops; i++) {
                        images.forEach(img => {
                            html += `<img src="${img}" alt="icon">`;
                        });
                    }
                    strip.innerHTML = html;
                });
            }

            let isSpinning = false;
            let spinTimeout;

            spinBtn.addEventListener('click', () => {
                if (isSpinning) {
                    skipSpin();
                    return;
                }

                isSpinning = true;
                spinBtn.textContent = "SKIP";
                try {
                    if (spinSound) spinSound.currentTime = 0;
                } catch (e) { }
                if (spinSound) spinSound.play().catch(e => console.log("Audio play failed", e));

                const results = [
                    Math.floor(Math.random() * numIcons),
                    Math.floor(Math.random() * numIcons),
                    Math.floor(Math.random() * numIcons)
                ];

                spinBtn.dataset.results = JSON.stringify(results);

                reelStrips.forEach((strip, index) => {
                    const targetIndex = results[index];
                    const targetPosition = ((loops - 2) * numIcons + targetIndex) * iconHeight;

                    strip.style.transition = 'none';
                    strip.style.transform = 'translateY(0)';
                    strip.offsetHeight;

                    const duration = 1.0 + (index * 0.1);
                    strip.style.transition = `transform ${duration}s cubic-bezier(0.2, 0.8, 0.2, 1)`;
                    strip.style.transform = `translateY(-${targetPosition}px)`;
                });

                spinTimeout = setTimeout(() => {
                    finishSpin(results);
                }, 1300);
            });

            function skipSpin() {
                clearTimeout(spinTimeout);
                const results = JSON.parse(spinBtn.dataset.results);
                reelStrips.forEach((strip, index) => {
                    const targetIndex = results[index];
                    const targetPosition = ((loops - 2) * numIcons + targetIndex) * iconHeight;
                    strip.style.transition = 'none';
                    strip.style.transform = `translateY(-${targetPosition}px)`;
                });
                finishSpin(results);
            }

            function finishSpin(results) {
                isSpinning = false;
                spinBtn.textContent = "SPIN";
                if (spinSound) spinSound.pause();

                const img1 = images[results[0]];
                const img2 = images[results[1]];
                const img3 = images[results[2]];

                if (img1 === img2 && img2 === img3) {
                    triggerWin();
                }
            }

            function triggerWin() {
                scamOverlay.style.display = 'flex';
            }

            // --- GAME LOGIC ---
            const startGameBtn = document.getElementById('startGameBtn');
            const gameOverlay = document.getElementById('gameOverlay');
            const gameCanvas = document.getElementById('gameCanvas');
            const finishGameBtn = document.getElementById('finishGameBtn');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const healthBarFill = document.getElementById('healthBarFill');

            // Menus
            const postGameMenu = document.getElementById('postGameMenu');
            const shopMenu = document.getElementById('shopMenu');
            const restartBtn = document.getElementById('restartBtn');
            const shopBtn = document.getElementById('shopBtn');
            const shopMoneyDisplay = document.getElementById('shopMoneyDisplay');

            let maxPlayerHP = 10;
            // gameRunning = false; (Already declared globally)
            // isPaused = false; (Already declared globally)

            // Focus handling (Moved here to avoid TDZ)
            document.addEventListener('visibilitychange', () => {
                const bg1 = document.getElementById('bgMusic');
                const bg2 = document.getElementById('bgMusic2');
                const activeMusic = (typeof currentLevel !== 'undefined' && currentLevel === 2) ? bg2 : bg1;
                if (document.hidden) {
                    if (activeMusic && gameRunning && !isPaused) activeMusic.pause();
                } else {
                    if (activeMusic && gameRunning && !isPaused) {
                        activeMusic.play().catch(e => console.log("Audio play failed on return", e));
                    }
                }
            });

            let ctx = gameCanvas.getContext('2d');
            let playerX = 0;
            let bullets = [];
            let enemies = [];
            let particles = [];
            let bossMissiles = [];
            let lastTime = 0;
            let enemySpawnTimer = 0;
            let gameOver = false;
            let gameElapsedTime = 0;
            let playerHP = 10;

            // Level 2 State
            // currentLevel = 1; (Already declared globally)
            // level2Phase = 0; (Already declared globally)
            let playerY = 0;
            let playerAngle = 0;
            let keysPressed = {};
            let mouseX = 0;
            let mouseY = 0;
            let dashCooldown = 0;
            let dashTimer = 0;
            let wasdShowState = 0; // 0=waiting, 1=showing, 2=keyPressed, 3=done
            let wasdHideTimer = 0;

            window.addEventListener('keydown', (e) => { keysPressed[e.key.toLowerCase()] = true; });
            window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });
            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            window.startLevel2 = function () {
                currentLevel = 2;
                level2Phase = 1;
                gameRunning = true;
                isPaused = false;
                gameOver = false;
                gameWon = false;
                lastTime = performance.now();
                gameElapsedTime = 0;
                playerHP = 10;
                updateHealthUI();
                wasdShowState = 0;
                dashCooldown = 0;
                dashTimer = 0;
                mirrorGlideMode = false; // Reset glide state
                mirrorX = 40; mirrorY = 50; // Reset position
                bullets = [];
                enemies = [];
                particles = [];
                bossMissiles = [];
                bossMissiles = [];
                // hasMirrorShip = false; // Removed to persist if bought

                bgMusic.pause();
                bgMusic.currentTime = 0;
                bgMusic2.currentTime = 32;
                bgMusic2.play().catch(e => console.log("Audio play failed", e));
                document.getElementById('memeLayerEnemies').innerHTML = '';

                // Level 2 Background defaults to black/transparent initially
                const bg = document.getElementById('gameBackground');
                if (bg) {
                    bg.style.backgroundImage = "none";
                    bg.style.backgroundColor = "rgba(0, 0, 0, 0.85)"; // Matches overlay
                }

                gameCanvas.width = window.innerWidth;
                gameCanvas.height = window.innerHeight;
                playerX = gameCanvas.width / 2;
                playerY = gameCanvas.height - 50;

                if (!unlockedLevel2) {
                    unlockedLevel2 = true;
                    saveGameState();
                }
                updateLevelButtons();

                const btn2 = document.getElementById('level2SelectBtn');
                if (btn2) btn2.classList.add('active-level');
                const btn1 = document.getElementById('level1SelectBtn');
                if (btn1) btn1.classList.remove('active-level');

                gameOverlay.style.display = 'block';
                postGameMenu.style.display = 'none';
                if (!isLoopRunning) {
                    isLoopRunning = true;
                    requestAnimationFrame(gameLoop);
                }
            };

            function updateLevelButtons() {
                const btn2 = document.getElementById('level2SelectBtn');
                if (btn2) {
                    btn2.style.display = unlockedLevel2 ? 'block' : 'none';
                }
            }

            // Boss State
            let loadingProgress = 0; // 0 to 40
            let bossActive = false;
            let boss = {
                x: 0, y: -250, w: 200, h: 200,
                hp: 200, maxHp: 200,
                phase: 1, // 1=static, 2=moving
                moveTimer: 0,
                attackTimer: 0,
                laserState: 0, // 0=none, 1=warn, 2=fire, 3=cooldown
                laserTimer: 0,
                targetX: 0
            };

            // Meme System State
            let memeRandomTimer = 0;
            const memeFiles = ['meme_2.gif', 'meme_3.gif', 'meme_5.gif', 'meme_6.gif', 'meme1.gif', 'meme_4.gif', 'meme_7.gif'];
            let bossMemeTriggered = false;
            let screenShake = 0;
            let cameraSwayX = 0;
            let cameraSwayY = 0;

            // Preload boss image
            const bossImg = new Image();
            bossImg.src = './nemdabo.png';
            bossImg.onerror = () => console.error('nemdabo.png load failed');

            function showMeme(src, layerId, duration, className) {
                const layer = document.getElementById(layerId);
                if (!layer) return;

                const img = document.createElement('img');
                img.src = './' + src; // Explicit relative path
                img.onerror = () => console.error('Meme load failed:', img.src);
                img.className = 'meme-gif ' + className;
                img.style.display = 'block';
                layer.appendChild(img);

                setTimeout(() => {
                    if (img.parentNode) img.remove();
                }, duration);
            }

            // State
            // score = 0; (Already declared globally)
            // autoFireLevel = 0; (Already declared globally)
            // hasMirrorShip = false; (Already declared globally)
            let isMouseDown = false;
            let lastShotTime = 0;
            // Mirror Ship State for Level 2
            let mirrorX = 40;
            let mirrorY = 0;
            let mirrorAngle = 0; // Rotation for mirror ship
            let mirrorShotTimer = 0;
            let mirrorGlideMode = false; // triggered when WASD starts
            // unlockedLevel2 = false; // Moved to global scope

            // Global access for HTML onclicks
            window.buyUpgrade = function (type) {
                if (type === 1) {
                    if (score >= 50) { score -= 50; autoFireLevel = 1; }
                } else if (type === 2) {
                    if (score >= 70) { score -= 70; autoFireLevel = 2; }
                } else if (type === 3) {
                    if (score >= 150) { score -= 150; hasMirrorShip = true; }
                }
                saveGameState();
                updateShopUI();
            };

            window.resetData = function () {
                if (confirm("BIZTOSAN TÖRÖLNI AKAROD AZ ÖSSZES ADATODAT? (Dabonium, Upgradék, Feloldott pályák)")) {
                    localStorage.removeItem('daboMoney');
                    localStorage.removeItem('daboAutoFire');
                    localStorage.removeItem('daboMirrorShip');
                    localStorage.removeItem('daboUnlockedLevel2');
                    location.reload();
                }
            }

            window.closeShop = function () {
                shopMenu.style.display = 'none';
                if (gameRunning && !gameOver) {
                    isPaused = false; // Resume game
                    bgMusic.play().catch(e => console.log("Audio play failed", e));
                    lastTime = performance.now(); // Reset time to avoid jump
                } else {
                    postGameMenu.style.display = 'block';
                }
            }

            window.openShopIngame = function () {
                if (!gameRunning || gameOver) return;
                isPaused = true;
                bgMusic.pause();
                shopMenu.style.display = 'block';
                updateShopUI();
            }

            window.cheatScore = function () {
                let newScore = prompt("Mennyi Daboniumot szeretnél?", score);
                if (newScore !== null) {
                    let parsed = parseInt(newScore);
                    if (!isNaN(parsed)) {
                        score = parsed;
                        saveGameState();
                        updateShopUI(); // Updates displays
                    }
                }
            }

            function updateShopUI() {
                shopMoneyDisplay.textContent = score;
                scoreDisplay.textContent = score; // Sync main display
                updateGlobalMoney(score); // Use the sync function
                updateLevelButtons(); // NEW: sync level button visibility

                document.getElementById('upg1Btn').disabled = (score < 50 || autoFireLevel >= 1);
                document.getElementById('upg1Btn').innerText = autoFireLevel >= 1 ? "MEGVÉVE" : "50 Dabonium - Automáta (14/mp)";

                document.getElementById('upg2Btn').disabled = (score < 70 || autoFireLevel >= 2);
                document.getElementById('upg2Btn').innerText = autoFireLevel >= 2 ? "MEGVÉVE" : "70 Dabonium - Gyorstüzelés (20/mp + Dupla)";

                document.getElementById('upg3Btn').disabled = (score < 150 || hasMirrorShip);
                document.getElementById('upg3Btn').innerText = hasMirrorShip ? "MEGVÉVE" : "150 Dabonium - Tükörhajó";
            }

            startGameBtn.addEventListener('click', () => {
                startGame();
            });

            function startGame() {
                gameOverlay.style.display = 'block';
                postGameMenu.style.display = 'none';
                shopMenu.style.display = 'none';
                const winUI = document.getElementById('levelWinMenu');
                if (winUI) winUI.style.display = 'none';

                gameRunning = true;
                isPaused = false;
                gameWon = false;
                try {
                    if (bgMusic) { bgMusic.pause(); bgMusic.currentTime = 0; }
                    if (bgMusic2) { bgMusic2.pause(); bgMusic2.currentTime = 0; }
                } catch (e) { }
                if (bgMusic) bgMusic.play().catch(e => console.log("Audio play failed", e));
                gameOver = false;
                lastTime = performance.now();
                gameElapsedTime = 0;
                loadingProgress = 0;
                bossActive = false;
                screenShake = 0;

                // Reset Entities
                bullets = [];
                enemies = [];
                particles = [];
                bossMissiles = [];
                isMouseDown = false;
                const enemyLayer = document.getElementById('memeLayerEnemies');
                if (enemyLayer) enemyLayer.innerHTML = '';

                // Reset Memes
                memeRandomTimer = 0;
                bossMemeTriggered = false;
                const mBehind = document.getElementById('memeLayerBehind');
                if (mBehind) mBehind.innerHTML = '';
                const mAbove = document.getElementById('memeLayerAbove');
                if (mAbove) mAbove.innerHTML = '';

                // Set Level 1 Background
                const bg = document.getElementById('gameBackground');
                if (bg) {
                    bg.style.backgroundImage = "url('./hatter.jpg')";
                    bg.style.backgroundSize = "cover";
                    bg.style.backgroundPosition = "center";
                    bg.style.backgroundColor = "transparent";
                    bg.style.transform = "none";
                }

                // Level 1 Reset
                currentLevel = 1;
                level2Phase = 0;
                playerHP = 10;
                updateHealthUI();
                playerAngle = 0;
                dashCooldown = 0;
                dashTimer = 0;
                wasdShowState = 0;
                const wasdImg = document.getElementById('wasdTutorial');
                if (wasdImg) wasdImg.style.display = 'none';

                updateLevelButtons();
                const btn1 = document.getElementById('level1SelectBtn');
                if (btn1) btn1.classList.add('active-level');
                const btn2 = document.getElementById('level2SelectBtn');
                if (btn2) btn2.classList.remove('active-level');

                // Set canvas size (Moved up before positioning)
                gameCanvas.width = window.innerWidth;
                gameCanvas.height = window.innerHeight;
                playerX = gameCanvas.width / 2;
                playerY = gameCanvas.height - 50;

                if (!isLoopRunning) {
                    isLoopRunning = true;
                    requestAnimationFrame(gameLoop);
                }
            }

            function updateHealthUI() {
                const pct = Math.max(0, (playerHP / maxPlayerHP) * 100);
                if (healthBarFill) {
                    healthBarFill.style.width = pct + "%";
                    if (playerHP <= 3) healthBarFill.style.backgroundColor = "red";
                    else if (playerHP <= 6) healthBarFill.style.backgroundColor = "orange";
                    else healthBarFill.style.backgroundColor = "#00ff00";
                }
            }

            finishGameBtn.addEventListener('click', () => {
                // Hard exit
                gameRunning = false;
                bgMusic.pause();
                bgMusic.currentTime = 0;
                const bgMusic2 = document.getElementById('bgMusic2');
                if (bgMusic2) {
                    bgMusic2.pause();
                    bgMusic2.currentTime = 0;
                }
                gameOverlay.style.display = 'none';
            });

            restartBtn.addEventListener('click', () => {
                if (currentLevel === 2) {
                    startLevel2();
                } else {
                    startGame();
                }
            });

            shopBtn.addEventListener('click', () => {
                postGameMenu.style.display = 'none';
                shopMenu.style.display = 'block';
                updateShopUI();
            });

            document.addEventListener('keydown', (e) => {
                if ((e.key === 'z' || e.key === 'Z') && gameRunning && !bossActive) {
                    loadingProgress = 40; // Cheat: Instant Boss
                }
            });

            gameCanvas.addEventListener('mousemove', (e) => {
                if (!isPaused) {
                    if (currentLevel === 1 || (currentLevel === 2 && level2Phase < 2)) {
                        playerX = e.clientX;
                    }
                }
            });
            gameCanvas.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                if (!gameOver && gameRunning && !isPaused) {
                    spawnBullet();
                }
            });
            gameCanvas.addEventListener('mouseup', () => { isMouseDown = false; });
            gameCanvas.addEventListener('mouseleave', () => { isMouseDown = false; }); // Safety

            function spawnBullet() {
                if (isPaused) return;

                // Main Ship Bullets (Upwards) - Level 1 ONLY or Level 2 Phase 1 (Standard)
                if (currentLevel === 1 || (currentLevel === 2 && level2Phase < 2)) {
                    if (autoFireLevel === 2) {
                        bullets.push({ x: playerX - 15, y: gameCanvas.height - 50, width: 10, height: 10, vx: 0, vy: -10 });
                        bullets.push({ x: playerX + 5, y: gameCanvas.height - 50, width: 10, height: 10, vx: 0, vy: -10 });
                    } else {
                        bullets.push({ x: playerX - 5, y: gameCanvas.height - 50, width: 10, height: 10, vx: 0, vy: -10 });
                    }
                } else if (currentLevel === 2 && level2Phase >= 2) {
                    // Level 2 Phase 2 (WASD) Shooting
                    // Fire logic is changed in gameLoop to 1.6x interval.

                    let dx = mouseX - playerX;
                    let dy = mouseY - playerY;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    // 90% speed of previous 48 (which was the directed bullet speed from Level 1 side ship)
                    let speed = 48 * 0.9;
                    let vx = (dx / dist) * speed;
                    let vy = (dy / dist) * speed;

                    // Shoot 2 bullets
                    bullets.push({ x: playerX - 10, y: playerY, width: 10, height: 10, vx: vx, vy: vy });
                    bullets.push({ x: playerX + 10, y: playerY, width: 10, height: 10, vx: vx, vy: vy });
                }

                // Second Ship (Side Ship) - Shoot in Level 1 OR Level 2 before glide
                if (hasMirrorShip && (currentLevel === 1 || (currentLevel === 2 && !mirrorGlideMode))) {
                    let ratio = playerX / gameCanvas.width;
                    let sideY = (gameCanvas.height - 100) * ratio + 50;

                    if (autoFireLevel === 2) {
                        bullets.push({ x: 40, y: sideY - 10, width: 10, height: 10, vx: 10, vy: 0 }); // Shoot Right
                        bullets.push({ x: 40, y: sideY + 10, width: 10, height: 10, vx: 10, vy: 0 });
                    } else {
                        bullets.push({ x: 40, y: sideY, width: 10, height: 10, vx: 10, vy: 0 });
                    }
                }
            }

            let gameWon = false;

            function gameLoop(timestamp) {
                if (!gameRunning) {
                    isLoopRunning = false;
                    return;
                }

                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;

                if (isPaused) {
                    requestAnimationFrame(gameLoop);
                    return;
                }

                // Visual Effects Math
                let swayTime = timestamp / 1000;
                cameraSwayX = Math.sin(swayTime * 0.5) * 8;
                cameraSwayY = Math.cos(swayTime * 0.45) * 8;

                let curShakeX = (Math.random() - 0.5) * screenShake;
                let curShakeY = (Math.random() - 0.5) * screenShake;
                if (screenShake > 0) screenShake *= 0.85;

                // Background Movement
                const bgLayer = document.getElementById('gameBackground');
                if (bgLayer) {
                    bgLayer.style.transform = `translate(${cameraSwayX + curShakeX}px, ${cameraSwayY + curShakeY}px) scale(1.1)`;
                }

                if (gameWon) {
                    const winUI = document.getElementById('levelWinMenu');
                    const statusText = document.getElementById('winStatusText');
                    const nextBtn = document.getElementById('nextLevelBtn');
                    const winShopBtn = document.getElementById('winShopBtn');
                    const winExitBtn = document.getElementById('winExitBtn');

                    if (winUI && winUI.style.display !== 'block') {
                        statusText.textContent = `${currentLevel}. PÁLYA TELJESÍTVE`;
                        winUI.style.display = 'block';

                        // Show NEXT LEVEL button only if level 1
                        nextBtn.style.display = (currentLevel === 1) ? 'block' : 'none';

                        nextBtn.onclick = () => {
                            winUI.style.display = 'none';
                            gameWon = false;
                            startLevel2();
                        };

                        winShopBtn.onclick = () => {
                            winUI.style.display = 'none';
                            openShopIngame();
                        };

                        winExitBtn.onclick = () => {
                            winUI.style.display = 'none';
                            gameWon = false;
                            document.getElementById('finishGameBtn').click();
                        };

                        unlockedLevel2 = true;
                        saveGameState();
                        updateLevelButtons();
                    }
                    isLoopRunning = false;
                    return;
                }

                if (!gameOver) {
                    gameElapsedTime += deltaTime;

                    if (currentLevel === 2) {
                        const bgMusic2 = document.getElementById('bgMusic2');
                        let ct = bgMusic2.currentTime;

                        // WASD Tutorial Logic
                        const wasdImg = document.getElementById('wasdTutorial');
                        if (ct >= 42 && wasdShowState === 0) {
                            wasdShowState = 1;
                            if (wasdImg) wasdImg.style.display = 'block';
                            // Clear all enemies strictly when WASD appears
                            enemies.forEach(e => { if (e.dom) e.dom.remove(); });
                            enemies = [];
                            mirrorGlideMode = true; // Start mirror ship glide
                        }

                        if (wasdShowState === 1) {
                            if (keysPressed['w'] || keysPressed['a'] || keysPressed['s'] || keysPressed['d']) {
                                wasdShowState = 2;
                                wasdHideTimer = 2000; // 2 seconds
                            }
                        } else if (wasdShowState === 2) {
                            wasdHideTimer -= deltaTime;
                            if (wasdHideTimer <= 0) {
                                wasdShowState = 3;
                                if (wasdImg) wasdImg.style.display = 'none';
                            }
                        }

                        let oldPhase = level2Phase;
                        if (ct >= 48) level2Phase = 3;
                        else if (ct >= 43) level2Phase = 2;
                        else level2Phase = 1;

                        if (oldPhase === 1 && level2Phase === 2) {
                            // Clear ALL enemies on transition to WASD (including falling ones)
                            enemies.forEach(e => { if (e.dom) e.dom.remove(); });
                            enemies = [];
                            enemySpawnTimer = 0; // Reset spawn timer
                        }

                        if (oldPhase === 2 && level2Phase === 3) {
                            // Clear enemies again when rainbow phase starts
                            enemies.forEach(e => { if (e.dom) e.dom.remove(); });
                            enemies = [];
                            enemySpawnTimer = 0;
                        }

                        if (level2Phase >= 2) {
                            // Dash Cooldown
                            if (dashCooldown > 0) dashCooldown -= deltaTime;
                            if (dashTimer > 0) dashTimer -= deltaTime;

                            // Dash Trigger
                            if (keysPressed['shift'] && dashCooldown <= 0) {
                                dashTimer = 150; // 150ms dash
                                dashCooldown = 2000; // 2s cooldown
                            }

                            let speed = 8.5; // 70% faster (5 * 1.7)
                            if (dashTimer > 0) speed *= 4; // Dash burst

                            if (keysPressed['w']) playerY -= speed;
                            if (keysPressed['s']) playerY += speed;
                            if (keysPressed['a']) playerX -= speed;
                            if (keysPressed['d']) playerX += speed;

                            playerX = Math.max(20, Math.min(gameCanvas.width - 20, playerX));
                            playerY = Math.max(20, Math.min(gameCanvas.height - 20, playerY));

                            playerAngle = Math.atan2(mouseY - playerY, mouseX - playerX) + Math.PI / 2;
                        }
                    }

                    // Loading / Boss Timer
                    if (currentLevel === 1 && !bossActive) {
                        if (loadingProgress < 40) {
                            loadingProgress += deltaTime / 1000;
                        }
                        if (loadingProgress >= 40) {
                            bossActive = true;
                            loadingProgress = 40;
                            boss.y = -250;
                        }
                    }

                    // Auto Fire Logic
                    if (isMouseDown && (autoFireLevel > 0 || (currentLevel === 2 && level2Phase >= 2))) {
                        // Base interval
                        let fireInterval = autoFireLevel === 2 ? (1000 / 20) : (1000 / 14);

                        // Level 2 Phase 2 modification: 60% slower -> interval * 1.6
                        if (currentLevel === 2 && level2Phase >= 2) {
                            fireInterval = fireInterval * 1.6;
                            // Also ensure it shoots even if autoFireLevel is 0, if that's desired behavior for L2
                            // But usually mouse click shoots anyway. 
                        }

                        if (timestamp - lastShotTime > fireInterval) {
                            spawnBullet();
                            lastShotTime = timestamp;
                        }
                    }
                }

                ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                ctx.save();
                ctx.translate(cameraSwayX + curShakeX, cameraSwayY + curShakeY);

                if (gameOver) {
                    ctx.font = "bold 60px 'Outfit', sans-serif";
                    ctx.fillStyle = "red";
                    ctx.textAlign = "center";
                    ctx.fillText("vesztettélxdddd", gameCanvas.width / 2, gameCanvas.height / 2);
                }

                // Draw Player
                drawSpaceship(playerX, (currentLevel === 2 && level2Phase >= 2) ? playerY : (gameCanvas.height - 50));

                // Draw Side Ship (Mirror Ship)
                if (hasMirrorShip) {
                    let drawMx, drawMy;

                    if (currentLevel === 1) {
                        let ratio = playerX / gameCanvas.width;
                        drawMx = 40;
                        drawMy = (gameCanvas.height - 100) * ratio + 50;
                        // Sync internal state for transition
                        mirrorX = drawMx; mirrorY = drawMy;
                    } else {
                        // Level 2 Logic
                        if (!mirrorGlideMode) {
                            // Before Glide: Still on side rail (mimic Level 1 behavior relative to center player)
                            // Player starts at center in Level 2 phase 0/1
                            let ratio = playerX / gameCanvas.width;
                            drawMx = 40;
                            drawMy = (gameCanvas.height - 100) * ratio + 50;
                            mirrorX = drawMx; mirrorY = drawMy;
                        } else {
                            // Glide / Follow Mode
                            let targetX = playerX - 50;
                            let targetY = playerY - 40;

                            // Smooth Lerp (approx 2s for full travel, per frame 0.05 factor at 60fps is fastish, use smaller for slow glide)
                            // 2 seconds... maybe 0.02 per frame?
                            // Let's use deltaTime for consistency
                            let lerpFactor = 0.005 * deltaTime; // e.g. 16ms * 0.005 = 0.08
                            if (lerpFactor > 1) lerpFactor = 1;

                            mirrorX += (targetX - mirrorX) * lerpFactor;
                            mirrorY += (targetY - mirrorY) * lerpFactor;

                            drawMx = mirrorX;
                            drawMy = mirrorY;

                            // Calculate rotation only during glide mode
                            let dx = mouseX - mirrorX;
                            let dy = mouseY - mirrorY;
                            mirrorAngle = Math.atan2(dy, dx) + Math.PI / 2;
                        }
                    }

                    ctx.save();
                    if (mirrorGlideMode && currentLevel === 2) {
                        ctx.translate(drawMx, drawMy);
                        ctx.rotate(mirrorAngle);
                        ctx.translate(-drawMx, -drawMy);
                    }

                    // Draw rotated small ship on left (x=20)
                    ctx.fillStyle = "orange"; // Distinct color
                    ctx.fillRect(drawMx - 10, drawMy - 10, 20, 20); // Body
                    ctx.fillStyle = "yellow";
                    ctx.fillRect(drawMx + 10, drawMy - 5, 10, 10); // Nose pointing right (or wherever)

                    ctx.restore();
                }

                // Draw Loading Bar
                if (currentLevel === 1 && !bossActive && !gameOver) {
                    let barW = 300;
                    let barH = 10;
                    let lx = (gameCanvas.width / 2) - (barW / 2);
                    let ly = 50; // Top center

                    ctx.fillStyle = "#555";
                    ctx.fillRect(lx, ly, barW, barH);

                    let fillW = (loadingProgress / 40) * barW;
                    ctx.fillStyle = "#00ffff";
                    ctx.fillRect(lx, ly, fillW, barH);

                    ctx.strokeStyle = "white";
                    ctx.strokeRect(lx, ly, barW, barH);

                    ctx.fillStyle = "white";
                    ctx.font = "16px sans-serif";
                    ctx.textAlign = "center";
                    ctx.fillText(`BOSS BETÖLTÉS: ${Math.floor((loadingProgress / 40) * 100)}%`, gameCanvas.width / 2, ly - 10);
                }

                // Endless Message Level 2
                if (currentLevel === 2 && gameElapsedTime > 30000) {
                    ctx.font = "bold 30px 'Outfit', sans-serif";
                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                    ctx.textAlign = "center";
                    ctx.fillText("Ez endless amúgy szóval ennyi xd", gameCanvas.width / 2, 50);
                }

                if (!gameOver) {
                    // Update and Draw Bullets
                    ctx.fillStyle = "#00ff00";
                    for (let i = bullets.length - 1; i >= 0; i--) {
                        let b = bullets[i];

                        // Handle custom velocities if existent (for side ship)
                        // If vx/vy missing, assume standard (0, -scaling)
                        // The provided vx/vy are fixed pixel movements per frame.
                        if (b.vx !== undefined) {
                            b.x += b.vx;
                            b.y += b.vy;
                        } else {
                            // Fallback for old bullets just in case, or if we want main ship bullets to scale with deltaTime
                            // For consistency with new vx/vy, let's assume main ship bullets also use fixed vy.
                            // If the original behavior of deltaTime scaling is desired, this line should be:
                            // b.y -= (gameCanvas.height / 1000) * deltaTime;
                            // But the instruction provided `vy: -10` for main bullets, implying fixed speed.
                            b.y += b.vy; // Use the fixed vy from spawnBullet
                        }

                        // Drawing Bullets with Shadow
                        ctx.fillStyle = "black";
                        ctx.fillRect(b.x - 5 + 4, b.y + 4, b.width, b.height); // Shadow
                        ctx.fillStyle = (currentLevel === 2 && level2Phase === 3) ? `hsl(${Date.now() % 360}, 100%, 50%)` : "white";
                        ctx.fillRect(b.x - 5, b.y, b.width, b.height);
                        if (b.y < 0 || b.x < 0 || b.x > gameCanvas.width || b.y > gameCanvas.height) bullets.splice(i, 1);
                    }

                    // Boss Mechanics
                    if (bossActive) {
                        // Move Boss into position (Y=150)
                        if (boss.y < 150) {
                            boss.y += (100 * deltaTime / 1000); // Slide down
                        } else {
                            // Phase 2 Movement
                            if (boss.hp <= 100) {
                                boss.moveTimer += deltaTime;
                                boss.x = (gameCanvas.width / 2 - boss.w / 2) + Math.sin(boss.moveTimer / 1000) * 200;
                                boss.y = 150 + Math.sin(boss.moveTimer / 1200) * 40;
                            } else {
                                boss.x = (gameCanvas.width / 2 - boss.w / 2); // Center
                            }
                        }

                        // Render Boss
                        let bossScale = 0.5 + 0.5 * (boss.hp / 200);
                        let currW = boss.w * bossScale;
                        let currH = boss.h * bossScale;
                        let drawX = boss.x + (boss.w - currW) / 2;
                        let drawY = boss.y + (boss.h - currH) / 2;

                        // Draw nemdabo.png as boss
                        if (bossImg.complete) {
                            ctx.drawImage(bossImg, drawX, drawY, currW, currH);
                        } else {
                            // Fallback to colored rectangle
                            ctx.fillStyle = boss.hp > 100 ? "red" : "darkred";
                            ctx.fillRect(drawX, drawY, currW, currH);
                        }

                        // Boss HP Bar
                        ctx.fillStyle = "black";
                        ctx.fillRect(drawX, drawY - 20, currW, 10);
                        ctx.fillStyle = "lime";
                        ctx.fillRect(drawX, drawY - 20, currW * (boss.hp / 200), 10);

                        // Attacks
                        boss.attackTimer += deltaTime;
                        // Bouncing Missiles every 3s
                        if (boss.attackTimer > 3000) {
                            // Calculate initial vector towards player for start
                            let startDx = playerX - (boss.x + boss.w / 2);
                            let startDy = (gameCanvas.height - 50) - (boss.y + boss.h);
                            let dist = Math.sqrt(startDx * startDx + startDy * startDy);
                            let ivx = (startDx / dist) * 5;
                            let ivy = (startDy / dist) * 5;

                            bossMissiles.push({
                                x: boss.x + boss.w / 2,
                                y: boss.y + boss.h,
                                w: 20, h: 20,
                                vx: ivx, vy: ivy
                            });
                            boss.attackTimer = 0;
                        }

                        // Laser Attack
                        if (Math.random() < 0.005 && boss.laserState === 0) {
                            boss.laserState = 1; // Warn
                            boss.laserTimer = 1500;
                        }

                        if (boss.laserState > 0) {
                            boss.laserTimer -= deltaTime;
                            let centerX = boss.x + boss.w / 2;

                            if (boss.laserState === 1) { // Warning
                                ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
                                ctx.fillRect(centerX - 20, boss.y + boss.h, 40, gameCanvas.height);
                                if (boss.laserTimer <= 0) {
                                    boss.laserState = 2; // Fire
                                    boss.laserTimer = 3000;
                                }
                            } else if (boss.laserState === 2) { // Fire
                                ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
                                ctx.fillRect(centerX - 40, boss.y + boss.h, 80, gameCanvas.height);

                                // Laser Collision
                                if (playerX > centerX - 40 && playerX < centerX + 40) {
                                    takeDamage(1);
                                }

                                if (boss.laserTimer <= 0) {
                                    boss.laserState = 3;
                                    boss.laserTimer = 2000; // Cooldown
                                }
                            } else if (boss.laserState === 3) {
                                if (boss.laserTimer <= 0) boss.laserState = 0;
                            }
                        }

                        // Bullet vs Boss
                        for (let i = bullets.length - 1; i >= 0; i--) {
                            let b = bullets[i];
                            if (rectIntersect(b.x, b.y, b.width, b.height, drawX, drawY, currW, currH)) {
                                boss.hp -= 1;
                                createExplosion(b.x, b.y, "orange");
                                bullets.splice(i, 1);
                                if (boss.hp <= 0) {
                                    score += 1000;
                                    scoreDisplay.textContent = score;
                                    score += 1000;
                                    scoreDisplay.textContent = score;
                                    updateGlobalMoney(score);
                                    bossActive = false;
                                    gameWon = true; // Trigger Win
                                }
                            }
                        }
                    }

                    // Boss Missiles Update (Bouncing)
                    for (let i = bossMissiles.length - 1; i >= 0; i--) {
                        let m = bossMissiles[i];

                        m.x += m.vx;
                        m.y += m.vy;

                        // Bounce Logic
                        let bounced = false;
                        // Only reflect Y, no horizontal bounce
                        if (m.y <= 0 || m.y + m.h >= gameCanvas.height) {
                            m.vy *= -1; // Reflect Y
                            bounced = true;
                        }

                        if (bounced) {
                            let angle = Math.random() * Math.PI * 2;
                            // Enforce non-horizontal bounce (vertical component must be significant)
                            // We want vy to be at least, say, 0.3 of speed
                            // Loop until Angle is safe? Or just clamp?
                            let safe = false;
                            while (!safe) {
                                angle = Math.random() * Math.PI * 2;
                                if (Math.abs(Math.sin(angle)) > 0.3) safe = true;
                            }

                            let speed = 5;
                            m.vx = Math.cos(angle) * speed;
                            m.vy = Math.sin(angle) * speed;

                            // Pull back in bounds slightly to avoid sticking
                            // Only for Y, as X is not bouncing off walls
                            if (m.y <= 0) m.y = 1;
                            if (m.y + m.h >= gameCanvas.height) m.y = gameCanvas.height - m.h - 1;
                        }

                        // Drawing Boss Missile with Shadow
                        ctx.fillStyle = "black";
                        ctx.fillRect(m.x + 4, m.y + 4, m.w, m.h); // Shadow
                        ctx.fillStyle = "purple";
                        ctx.fillRect(m.x, m.y, m.w, m.h);

                        if (rectIntersect(m.x, m.y, m.w, m.h, playerX - 20, gameCanvas.height - 50, 40, 40)) {
                            takeDamage(1);
                            bossMissiles.splice(i, 1);
                        }
                    }

                    // Spawning
                    let spawnRate = bossActive ? 666 : 3000; // Halved enemy spawn (was 333 and 1500)
                    if (currentLevel === 2) {
                        spawnRate = level2Phase === 3 ? 200 : 333; // 5/s or 3/s
                    } else if (!bossActive) {
                        if (gameElapsedTime > 5000) {
                            const progress = Math.min((gameElapsedTime - 5000) / 15000, 1);
                            spawnRate = 3000 - (2800 * progress); // Halved (was 1500 - 1400)
                        }
                    }

                    enemySpawnTimer += deltaTime;
                    while (enemySpawnTimer > spawnRate) {
                        enemySpawnTimer -= spawnRate;

                        let ex, ey, isRainbow = false, isPiros = false;
                        if (currentLevel === 2) {
                            if (level2Phase === 3) {
                                let side = Math.floor(Math.random() * 4);
                                if (side === 0) { ex = Math.random() * gameCanvas.width; ey = -50; }
                                else if (side === 1) { ex = Math.random() * gameCanvas.width; ey = gameCanvas.height + 50; }
                                else if (side === 2) { ex = -50; ey = Math.random() * gameCanvas.height; }
                                else { ex = gameCanvas.width + 50; ey = Math.random() * gameCanvas.height; }
                                isRainbow = true;
                            } else {
                                ex = Math.random() * (gameCanvas.width - 40) + 20;
                                ey = -50;
                                isPiros = true;
                            }
                        } else {
                            ex = Math.random() * (gameCanvas.width - 40) + 20;
                            ey = -50;
                        }

                        let isFekete = currentLevel === 1 && Math.random() < 0.1;
                        enemies.push({
                            x: ex, y: ey,
                            width: 40, height: 40,
                            color: isFekete ? "transparent" : (isPiros ? "red" : `hsl(${Math.random() * 360}, 100%, 50%)`),
                            isFekete: isFekete,
                            isRainbow: isRainbow,
                            isHoming: isRainbow
                        });
                    }

                    // Meme Handling (Level 2 Phase 3 ONLY)
                    if (currentLevel === 2 && level2Phase === 3) {
                        memeRandomTimer += deltaTime;
                        // "Random all gif 70%" -> High frequency random spawn
                        if (memeRandomTimer > 1500) { // Spawn one every 1.5s approx
                            memeRandomTimer = 0;
                            if (Math.random() < 0.7) {
                                const rndMeme = memeFiles[Math.floor(Math.random() * memeFiles.length)];
                                const rndLayer = Math.random() > 0.5 ? 'memeLayerAbove' : 'memeLayerBehind';
                                const duration = 3000 + Math.random() * 2000;
                                let cls = 'meme-full chroma-key-green';
                                showMeme(rndMeme, rndLayer, duration, cls);
                            }
                        }
                    }

                    // Update Entities
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        let e = enemies[i];

                        if (e.dying > 0) {
                            e.dying -= deltaTime;
                            if (e.dying <= 0) {
                                if (e.dom) e.dom.remove();
                                enemies.splice(i, 1);
                                continue;
                            }
                        } else {
                            if (e.isHoming) {
                                let dx = playerX - e.x;
                                let dy = playerY - e.y;
                                let dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    e.x += (dx / dist) * 3;
                                    e.y += (dy / dist) * 3;
                                }
                            } else {
                                e.y += (gameCanvas.height / 5000) * deltaTime;
                            }
                        }

                        // Draw Enemy with Shake if dying
                        ctx.save();
                        if (e.dying > 0) {
                            ctx.translate((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                            ctx.globalAlpha = e.dying / 150;
                        }

                        if (!e.isFekete) {
                            // Shadow
                            ctx.fillStyle = "black";
                            ctx.fillRect(e.x - 20 + 7, e.y - 20 + 7, e.width, e.height);
                            // Entity
                            ctx.fillStyle = e.isRainbow ? `hsl(${Date.now() % 360}, 100%, 50%)` : e.color;
                            ctx.fillRect(e.x - 20, e.y - 20, e.width, e.height);
                        } else {
                            // "Fekete" Meme Enemy (DOM based)
                            if (!e.dom) {
                                e.dom = document.createElement('img');
                                e.dom.src = './meme_fekete.gif';
                                e.dom.onerror = () => console.error('meme_fekete.gif load failed');
                                e.dom.className = 'meme-gif chroma-key-black';
                                e.dom.style.width = e.width + 'px';
                                e.dom.style.height = e.height + 'px';
                                e.dom.style.display = 'block';
                                e.dom.style.boxShadow = "7px 7px 0px black";
                                document.getElementById('memeLayerEnemies').appendChild(e.dom);
                            }
                            if (e.dying > 0) {
                                e.dom.style.opacity = e.dying / 150;
                                e.dom.style.transform = `translate(${(Math.random() - 0.5) * 10}px, ${(Math.random() - 0.5) * 10}px)`;
                            } else {
                                e.dom.style.opacity = 1;
                                e.dom.style.transform = "none";
                            }
                            e.dom.style.left = (e.x - 20) + 'px';
                            e.dom.style.top = (e.y - 20) + 'px';
                        }
                        ctx.restore();

                        if (!e.dying) {
                            if (e.y > gameCanvas.height + 100 || e.y < -100 || e.x > gameCanvas.width + 100 || e.x < -100) {
                                if (currentLevel === 1 && !e.isHoming && e.y > gameCanvas.height) takeDamage(1);
                                if (e.dom) e.dom.remove();
                                enemies.splice(i, 1);
                            } else if (rectIntersect(e.x - 20, e.y - 20, e.width, e.height, playerX - 20, playerY - 20, 40, 40)) {
                                takeDamage(1);
                                if (e.dom) e.dom.remove();
                                enemies.splice(i, 1);
                            }
                        }
                    }

                    // Move Mirror Ship Shooting Logic here (inside gameLoop)
                    if (hasMirrorShip && currentLevel === 2 && level2Phase >= 2 && !gameOver) {
                        mirrorShotTimer += deltaTime;
                        if (mirrorShotTimer > 333) { // 3 shots per second
                            mirrorShotTimer = 0;
                            // Find nearest enemy
                            let nearest = null;
                            let minDist = Infinity;
                            enemies.forEach(e => {
                                let dist = Math.sqrt(Math.pow(e.x - mirrorX, 2) + Math.pow(e.y - mirrorY, 2));
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearest = e;
                                }
                            });

                            if (nearest) {
                                let dx = nearest.x - mirrorX;
                                let dy = nearest.y - mirrorY;
                                let dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    let speed = 15;
                                    bullets.push({
                                        x: mirrorX, y: mirrorY,
                                        width: 8, height: 8,
                                        vx: (dx / dist) * speed,
                                        vy: (dy / dist) * speed
                                    });
                                }
                            }
                        }
                    }
                }

                // Collision
                for (let i = bullets.length - 1; i >= 0; i--) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        let b = bullets[i]; let e = enemies[j];
                        if (!e.dying && rectIntersect(b.x - 5, b.y, 10, 10, e.x - 20, e.y - 20, 40, 40)) {
                            e.dying = 150; // 150ms shake
                            createExplosion(e.x, e.y, e.isFekete ? "white" : e.color);
                            bullets.splice(i, 1);
                            score++;
                            scoreDisplay.textContent = score;
                            updateGlobalMoney(score);
                            break;
                        }
                    }
                }

                // Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= deltaTime;
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 1000;
                    let s = p.size || 4;
                    ctx.fillRect(p.x - s / 2, p.y - s / 2, s, s);
                    ctx.globalAlpha = 1;
                    if (p.life <= 0) particles.splice(i, 1);
                }

                ctx.restore();

                requestAnimationFrame(gameLoop);
            }

            // Preload player image
            const playerImg = new Image();
            playerImg.src = './dabo.png';
            playerImg.onerror = () => console.error('dabo.png load failed');

            function drawSpaceship(x, y) {
                ctx.save();
                ctx.translate(x, y);
                if (currentLevel === 2 && level2Phase >= 2) {
                    ctx.rotate(playerAngle);
                }

                // Draw dabo.png image (15% larger than original 40x40 spaceship)
                const size = 46; // 40 * 1.15 = 46
                if (playerImg.complete) {
                    ctx.drawImage(playerImg, -size / 2, -size / 2, size, size);
                } else {
                    // Fallback to original spaceship if image not loaded
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(-2, -20, 4, 10);
                    ctx.fillRect(-10, -10, 20, 10);
                    ctx.fillRect(-20, 0, 40, 10);
                    ctx.fillStyle = "#00bcd4";
                    ctx.fillRect(-5, -5, 10, 10);
                }
                ctx.restore();
            }

            function createExplosion(x, y, color) {
                // Flash / Shake
                screenShake = Math.max(screenShake, 10);

                for (let i = 0; i < 18; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12,
                        size: 2 + Math.random() * 6,
                        life: 600 + Math.random() * 400,
                        color: color
                    });
                }
            }

            function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
                return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
            }

            function takeDamage(amount) {
                if (gameOver) return;
                playerHP -= amount;
                updateHealthUI();
                screenShake = 25; // Big shake
                createExplosion(playerX, (currentLevel === 2 && level2Phase >= 2) ? playerY : (gameCanvas.height - 50), "red");
                if (playerHP <= 0) {
                    triggerGameOver();
                }
            }

            function triggerGameOver() {
                gameOver = true;
                // Spawn 2 viruses
                createGameVirusPopup(1);
                createGameVirusPopup(2);
            }

            let activeGameViruses = 0;

            function createGameVirusPopup(index) {
                createVirusPopup(100 + index, true);
            }


            // --- VIRUS ATTACK LOGIC ---
            const virusImages = [
                '../wpviking/virus_alert_window.png',
                '../wpviking/claim_prize_banner.png',
                '../wpviking/sexy_single_ad.png',
                '../wpviking/free_money_banner.png',
                '../wpviking/logo.png',
                '../wpviking/201.gif'
            ];

            const virusTexts = [
                "VIRUS DETECTED!", "UNABLE TO STOP PROCESS", "YOUR COMPUTER IS INFECTED",
                "DOWNLOAD RAM FREE", "HOT SINGLES IN YOUR AREA", "YOU ARE THE 1,000,000TH VISITOR",
                "CLICK HERE TO CLAIM PRIZE", "SYSTEM32 DELETED", "ERROR 404: BRAIN NOT FOUND",
                "SEND MONEY NOW", "WIN IPHONE 75!!!", "TAKE SURVEY NOW", "DOWNLOAD ANTI-VIRUS",
                "INSTALL TOOLBAR", "FREE MP3 DOWNLOAD", "CONGRATULATIONS!", "YOUR IP IS PUBLIC",
                "WEBCAM ACTIVATED", "DATA CORRUPTION IMMINENT", "ILLEGAL OPERATION", "FATAL EXCEPTION 0E"
            ];

            const virusTitles = [
                "WARNING", "CRITICAL ERROR", "CONGRATS!", "HELLO?", "SYSTEM ALERT",
                "WINNER", "ADVERTISEMENT", "SURVEY", "DOWNLOAD", "IMPORTANT",
                "SECURITY", "CMD.EXE", "PRIZE NOTIFICATION"
            ];

            function createVirusPopup(index, isGameVirus = false) {
                const div = document.createElement('div');
                const styles = ['style-classic', 'style-terminal', 'style-alert', 'style-flashy'];
                const randomStyle = styles[Math.floor(Math.random() * styles.length)];
                div.className = 'popup ' + randomStyle;
                if (isGameVirus) activeGameViruses++;

                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const popupWidth = Math.min(300, viewportWidth * 0.8);

                div.style.width = popupWidth + 'px';

                const rX = Math.floor(Math.random() * (viewportWidth - popupWidth));
                const rY = Math.floor(Math.random() * (viewportHeight - 200));

                div.style.left = rX + 'px';
                div.style.top = rY + 'px';
                div.style.zIndex = 5000 + index;

                let contentHtml = '';
                if (Math.random() > 0.6) {
                    const img = virusImages[Math.floor(Math.random() * virusImages.length)];
                    contentHtml = `<img src="${img}" alt="spam">`;
                } else {
                    const txt = virusTexts[Math.floor(Math.random() * virusTexts.length)];
                    const fontSize = Math.floor(Math.random() * 10) + 16;
                    contentHtml = `<div style="font-size: ${fontSize}px; font-weight: bold;">${txt}</div><br><button style="cursor:pointer; padding: 5px;">${Math.random() > 0.5 ? 'OK' : 'CANCEL'}</button>`;
                }

                const title = virusTitles[Math.floor(Math.random() * virusTitles.length)];

                div.innerHTML = `
                    <div class="popup-header">
                        <span>${title}</span>
                        <div class="popup-close">X</div>
                    </div>
                    <div class="popup-content">
                        ${contentHtml}
                    </div>
                `;

                // Close handler
                const closeBtn = div.querySelector('.popup-close');
                closeBtn.onclick = function () {
                    div.remove();
                    if (isGameVirus) {
                        activeGameViruses--;
                        if (virusContainer.children.length === 0) {
                            // SHOW MENU INSTEAD OF CLOSE
                            postGameMenu.style.display = 'block';
                        }
                    } else {
                        if (virusContainer.children.length === 0) {
                            showRealWin();
                        }
                    }
                };

                virusContainer.appendChild(div);
            }

            function startVirusAttack() {
                const count = 15;
                for (let i = 0; i < count; i++) {
                    createVirusPopup(i);
                }
            }

            // SPACE key listener to clear viruses
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && virusContainer.children.length > 0) {
                    e.preventDefault();
                    if (gameRunning) {
                        virusContainer.innerHTML = '';
                        // SHOW MENU
                        postGameMenu.style.display = 'block';
                        // Stop game processing physically but don't close overlay
                    } else {
                        virusContainer.innerHTML = '';
                        showRealWin();
                    }
                }
            });

            claimBtn.addEventListener('click', () => {
                scamOverlay.style.display = 'none';
                startVirusAttack();
            });

            refuseBtn.addEventListener('click', () => {
                scamOverlay.style.display = 'none';
                hekasOverlay.style.display = 'flex';
            });

            function showRealWin() {
                if (winSound) {
                    winSound.currentTime = 0;
                    winSound.play().catch(e => console.log("Audio play failed", e));
                }
                winOverlay.style.display = 'flex';

                const duration = 5 * 1000;
                const animationEnd = Date.now() + duration;
                const defaults = {
                    startVelocity: 30,
                    spread: 360,
                    ticks: 60,
                    zIndex: 2000
                };

                function randomInRange(min, max) {
                    return Math.random() * (max - min) + min;
                }

                const interval = setInterval(function () {
                    const timeLeft = animationEnd - Date.now();
                    if (timeLeft <= 0) {
                        return clearInterval(interval);
                    }
                    const particleCount = 50 * (timeLeft / duration);
                    confetti(Object.assign({}, defaults, {
                        particleCount,
                        origin: {
                            x: randomInRange(0.1, 0.3),
                            y: Math.random() - 0.2
                        }
                    }));
                    confetti(Object.assign({}, defaults, {
                        particleCount,
                        origin: {
                            x: randomInRange(0.7, 0.9),
                            y: Math.random() - 0.2
                        }
                    }));
                }, 250);
            }
        });
    </script>

    <!-- Pac-Man Game Overlay -->
    <div id="pacmanOverlay" class="pacman-overlay">
        <div class="pacman-game-container">
            <canvas id="pacmanCanvas"></canvas>
            <div class="pacman-right-panel">
                <h2 style="margin-top: 0; color: #FFD700;">DABO-MAN</h2>
                <div class="pacman-stat">
                    <div class="pacman-label">DABONIUM</div>
                    <div class="pacman-value" id="pacmanScore">0</div>
                </div>
                <div class="pacman-stat">
                    <div class="pacman-label">LEVEL</div>
                    <div class="pacman-value" id="pacmanLevel">1</div>
                </div>
                <div class="pacman-stat">
                    <div class="pacman-label">LIVES</div>
                    <div class="pacman-lives" id="pacmanLives"></div>
                </div>
                <div id="pacmanGameOver" class="pacman-gameover">
                    GAME OVER
                </div>
            </div>
        </div>
        <button class="pacman-exit-btn" onclick="exitPacmanGame()">KILÉPÉS</button>
    </div>

    <style>
        /* Pac-Man Game Overlay Styles */
        .pacman-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .pacman-game-container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }

        #pacmanCanvas {
            border: 4px solid #2196F3;
            background: #000;
            box-shadow: 0 0 30px rgba(33, 150, 243, 0.5);
        }

        .pacman-right-panel {
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 30px 20px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            font-family: 'Outfit', sans-serif;
            color: white;
        }

        .pacman-stat {
            margin: 30px 0;
        }

        .pacman-label {
            font-size: 1.2rem;
            color: #FFD700;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .pacman-value {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            color: white;
        }

        .pacman-lives {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .pacman-life-icon {
            width: 30px;
            height: 30px;
            background: #FFFF00;
            border-radius: 50%;
            position: relative;
        }

        .pacman-life-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 15px solid #000;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            transform: translate(-30%, -50%);
        }

        .pacman-exit-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            padding: 15px 35px;
            font-size: 1.3rem;
            font-weight: bold;
            font-family: 'Outfit', sans-serif;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 0 #c62828;
            transition: all 0.1s;
        }

        .pacman-exit-btn:hover {
            background: #e53935;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #c62828;
        }

        .pacman-exit-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #c62828;
        }

        .pacman-gameover {
            display: none;
            font-size: 2rem;
            color: #FF0000;
            font-weight: bold;
            text-align: center;
            margin-top: 40px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }
    </style>

    <script>
        // Pac-Man Game Implementation
        function initPacmanGame() {
            const canvas = document.getElementById('pacmanCanvas');
            const ctx = canvas.getContext('2d');

            // Constants
            const TILE_SIZE = 20;
            const MAZE_WIDTH = 28;
            const MAZE_HEIGHT = 31;
            canvas.width = MAZE_WIDTH * TILE_SIZE;
            canvas.height = MAZE_HEIGHT * TILE_SIZE;

            // Game state
            let gameRunning = false;
            let score = 0;
            let lives = 3;
            let level = 1;
            let powerMode = false;
            let powerModeTimer = 0;
            const POWER_MODE_DURATION = 8000;
            let ghostsEatenThisPower = 0;

            // Maze layout (1=wall, 0=path, 2=pellet, 3=power pellet)
            const baseMaze = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
                [1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1],
                [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1],
                [1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
                [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
                [1, 3, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 3, 1],
                [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1],
                [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
                [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];

            let maze = JSON.parse(JSON.stringify(baseMaze));

            // Player (Pac-Man)
            class Player {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = 14;
                    this.y = 23;
                    this.dir = { x: 0, y: 0 };
                    this.nextDir = { x: 0, y: 0 };
                    // Visual offset to center the sprite on the tile path
                    // Coordinates are top-left of the tile, so add 0.5 to center
                    this.speed = 0.12;
                    this.mouthOpen = 0;
                    this.mouthSpeed = 0.2;
                }

                update() {
                    // Try to turn
                    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
                        const nx = this.x + this.nextDir.x * 0.5;
                        const ny = this.y + this.nextDir.y * 0.5;
                        if (!isWall(Math.floor(nx + 0.5), Math.floor(ny + 0.5))) {
                            this.dir = { ...this.nextDir };
                        }
                    }

                    // Move
                    if (this.dir.x !== 0 || this.dir.y !== 0) {
                        const nx = this.x + this.dir.x * this.speed;
                        const ny = this.y + this.dir.y * this.speed;

                        if (!isWall(Math.floor(nx + 0.5), Math.floor(ny + 0.5))) {
                            this.x = nx;
                            this.y = ny;
                        }
                    }

                    // Wrap
                    if (this.x < 0) this.x = MAZE_WIDTH - 1;
                    if (this.x >= MAZE_WIDTH) this.x = 0;

                    // Mouth animation
                    this.mouthOpen += this.mouthSpeed;
                    if (this.mouthOpen > 0.6 || this.mouthOpen < 0) this.mouthSpeed *= -1;

                    // Eat pellets
                    this.checkPellets();
                }

                checkPellets() {
                    const tx = Math.floor(this.x + 0.5);
                    const ty = Math.floor(this.y + 0.5);
                    if (maze[ty] && maze[ty][tx] === 2) {
                        maze[ty][tx] = 0;
                        addScore(3);
                        checkLevelComplete();
                    } else if (maze[ty] && maze[ty][tx] === 3) {
                        maze[ty][tx] = 0;
                        addScore(13);
                        activatePowerMode();
                        checkLevelComplete();
                    }
                }

                draw() {
                    const cx = (this.x + 0.5) * TILE_SIZE;
                    const cy = (this.y + 0.5) * TILE_SIZE;
                    const r = TILE_SIZE / 2 - 2;

                    let angle = 0;
                    if (this.dir.x > 0) angle = 0;
                    else if (this.dir.x < 0) angle = Math.PI;
                    else if (this.dir.y > 0) angle = Math.PI / 2;
                    else if (this.dir.y < 0) angle = -Math.PI / 2;

                    const mouth = this.mouthOpen * Math.PI / 4;

                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, angle + mouth, angle + 2 * Math.PI - mouth);
                    ctx.lineTo(cx, cy);
                    ctx.fill();
                }
            }

            // Ghost class
            class Ghost {
                constructor(x, y, color, targetMode) {
                    this.startX = x;
                    this.startY = y;
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    this.targetMode = targetMode;
                    this.dir = { x: 0, y: -1 };
                    this.speed = 0.08 * (1 + level * 0.05);
                    this.frightened = false;
                    this.respawnTimer = 0;
                    this.scatterTimer = 300;
                    this.runOut = true; // Force exit from ghost house
                }

                reset() {
                    this.x = this.startX;
                    this.y = this.startY;
                    this.dir = { x: 0, y: -1 };
                    this.frightened = false;
                    this.respawnTimer = 0;
                    this.scatterTimer = 300;
                    this.runOut = true;
                }

                update() {
                    if (this.respawnTimer > 0) {
                        this.respawnTimer--;
                        if (this.respawnTimer === 0) this.reset();
                        return;
                    }

                    const tx = Math.floor(this.x + 0.5);
                    const ty = Math.floor(this.y + 0.5);

                    // At tile center, pick direction
                    if (Math.abs(this.x - tx) < 0.05 && Math.abs(this.y - ty) < 0.05) {

                        if (this.runOut) {
                            if (ty <= 11) this.runOut = false;
                            else {
                                this.dir = { x: 0, y: -1 };
                                if (this.x < 13.4) this.x += 0.05;
                                if (this.x > 13.6) this.x -= 0.05;
                            }
                        }

                        if (!this.runOut) {
                            const dirs = [];
                            if (!isWall(tx + 1, ty) && this.dir.x !== -1) dirs.push({ x: 1, y: 0 });
                            if (!isWall(tx - 1, ty) && this.dir.x !== 1) dirs.push({ x: -1, y: 0 });
                            if (!isWall(tx, ty + 1) && this.dir.y !== -1) dirs.push({ x: 0, y: 1 });
                            if (!isWall(tx, ty - 1) && this.dir.y !== 1) dirs.push({ x: 0, y: -1 });

                            if (dirs.length > 0) {
                                if (this.frightened) {
                                    this.dir = dirs[Math.floor(Math.random() * dirs.length)];
                                } else {
                                    const px = Math.floor(player.x + 0.5);
                                    const py = Math.floor(player.y + 0.5);

                                    let best = dirs[0];
                                    let bestD = 9999;
                                    for (const d of dirs) {
                                        const dist = Math.abs(px - (tx + d.x)) + Math.abs(py - (ty + d.y));
                                        if (dist < bestD) {
                                            bestD = dist;
                                            best = d;
                                        }
                                    }
                                    this.dir = best;
                                }
                            }
                        }
                    }

                    // Move
                    this.x += this.dir.x * this.speed;
                    this.y += this.dir.y * this.speed;

                    // Wrap
                    if (this.x < 0) this.x = MAZE_WIDTH - 1;
                    if (this.x >= MAZE_WIDTH) this.x = 0;
                }

                getTarget() {
                    return { x: Math.floor(player.x + 0.5), y: Math.floor(player.y + 0.5) };
                }

                draw() {
                    if (this.respawnTimer > 0) return;

                    const centerX = this.x * TILE_SIZE + TILE_SIZE / 2;
                    const centerY = this.y * TILE_SIZE + TILE_SIZE / 2;
                    const radius = TILE_SIZE / 2 - 2;

                    ctx.fillStyle = this.frightened ? '#2196F3' : this.color;

                    // Body
                    ctx.beginPath();
                    ctx.arc(centerX, centerY - radius / 4, radius, Math.PI, 0, false);
                    ctx.lineTo(centerX + radius, centerY + radius);
                    ctx.lineTo(centerX + radius / 2, centerY + radius / 2);
                    ctx.lineTo(centerX, centerY + radius);
                    ctx.lineTo(centerX - radius / 2, centerY + radius / 2);
                    ctx.lineTo(centerX - radius, centerY + radius);
                    ctx.closePath();
                    ctx.fill();

                    // Eyes
                    if (!this.frightened) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(centerX - radius / 2, centerY - radius / 3, radius / 3, radius / 3);
                        ctx.fillRect(centerX + radius / 6, centerY - radius / 3, radius / 3, radius / 3);
                        ctx.fillStyle = 'black';
                        ctx.fillRect(centerX - radius / 3, centerY - radius / 4, radius / 6, radius / 6);
                        ctx.fillRect(centerX + radius / 4, centerY - radius / 4, radius / 6, radius / 6);
                    }
                }
            }

            // Initialize game objects
            const player = new Player();
            const ghosts = [
                new Ghost(13, 11, '#FF0000', 'chase'),
                new Ghost(14, 11, '#FFB8FF', 'ambush'),
                new Ghost(13, 13, '#00FFFF', 'patrol'),
                new Ghost(14, 13, '#FFB851', 'flank')
            ];

            // Helper functions
            function isWall(x, y) {
                if (y < 0 || y >= maze.length || x < 0 || x >= maze[0].length) return true;
                return maze[y][x] === 1;
            }

            function addScore(points) {
                score += points;
                updateGlobalDabonium(score);
                updateUI();
            }

            function activatePowerMode() {
                powerMode = true;
                powerModeTimer = POWER_MODE_DURATION;
                ghostsEatenThisPower = 0;
                ghosts.forEach(g => g.frightened = true);
            }

            function checkLevelComplete() {
                let pelletsLeft = 0;
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[y].length; x++) {
                        if (maze[y][x] === 2 || maze[y][x] === 3) pelletsLeft++;
                    }
                }
                if (pelletsLeft === 0) {
                    level++;
                    resetLevel();
                }
            }

            function resetLevel() {
                maze = JSON.parse(JSON.stringify(baseMaze));
                player.reset();
                ghosts.forEach(g => g.reset());
                updateUI();
            }

            function loseLife() {
                lives--;
                updateUI();
                if (lives <= 0) {
                    gameRunning = false;
                    document.getElementById('pacmanGameOver').style.display = 'block';
                } else {
                    player.reset();
                    ghosts.forEach(g => g.reset());
                }
            }

            function checkCollisions() {
                for (const ghost of ghosts) {
                    if (ghost.respawnTimer > 0) continue;
                    // Use center-to-center distance with a generous radius
                    const dist = Math.sqrt(Math.pow((player.x + 0.5) - (ghost.x + 0.5), 2) + Math.pow((player.y + 0.5) - (ghost.y + 0.5), 2));

                    if (dist < 0.8) { // Increased from 0.7 to 0.8 for reliable hit
                        if (powerMode && ghost.frightened) {
                            const points = [50, 100, 200, 400][ghostsEatenThisPower] || 400;
                            addScore(points);
                            ghostsEatenThisPower++;
                            ghost.respawnTimer = 120;
                        } else if (!powerMode) {
                            loseLife();
                            break;
                        }
                    }
                }
            }

            function updateUI() {
                document.getElementById('pacmanScore').textContent = score;
                document.getElementById('pacmanLevel').textContent = level;
                const livesContainer = document.getElementById('pacmanLives');
                livesContainer.innerHTML = '';
                for (let i = 0; i < lives; i++) {
                    const lifeIcon = document.createElement('div');
                    lifeIcon.className = 'pacman-life-icon';
                    livesContainer.appendChild(lifeIcon);
                }
            }

            function updateGlobalDabonium(newScore) {
                const currentGlobalScore = parseInt(localStorage.getItem('daboMoney') || '0');
                const diff = newScore - score;
                if (diff > 0) {
                    const newGlobal = currentGlobalScore + diff;
                    localStorage.setItem('daboMoney', newGlobal.toString());
                    const globalDisplays = [
                        document.getElementById('globalMoneyValue'),
                        document.getElementById('globalMoneyValueMobile'),
                        document.getElementById('scoreDisplay')
                    ];
                    globalDisplays.forEach(el => {
                        if (el) el.textContent = newGlobal;
                    });
                }
            }

            // Rendering
            function drawMaze() {
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[y].length; x++) {
                        const tile = maze[y][x];
                        if (tile === 1) {
                            ctx.fillStyle = '#2196F3';
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            ctx.strokeStyle = '#1565C0';
                            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        } else if (tile === 2) {
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (tile === 3) {
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            // Game loop
            function gameLoop() {
                if (!gameRunning) return;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawMaze();

                player.update();
                ghosts.forEach(g => g.update());
                checkCollisions();

                ghosts.forEach(g => g.draw());
                player.draw();

                // Update power mode
                if (powerMode) {
                    powerModeTimer -= 16.66;
                    if (powerModeTimer <= 0) {
                        powerMode = false;
                        ghosts.forEach(g => g.frightened = false);
                    }
                }

                requestAnimationFrame(gameLoop);
            }

            // Keyboard controls (Arrow keys + WASD)
            document.addEventListener('keydown', (e) => {
                if (!gameRunning) return;
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') player.nextDir = { x: -1, y: 0 };
                else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') player.nextDir = { x: 1, y: 0 };
                else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') player.nextDir = { x: 0, y: -1 };
                else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') player.nextDir = { x: 0, y: 1 };
            });

            // Start game
            gameRunning = true;
            updateUI();
            gameLoop();
        }

        // Game control functions
        function startPacmanGame() {
            const overlay = document.getElementById('pacmanOverlay');
            overlay.style.display = 'flex';
            document.getElementById('pacmanGameOver').style.display = 'none';
            initPacmanGame();
        }

        function exitPacmanGame() {
            const overlay = document.getElementById('pacmanOverlay');
            overlay.style.display = 'none';
        }
    </script>

    <!-- Secondary styles removed to fix layout conflicts -->
    <button class="reset-btn" onclick="resetData()">RESET</button>
</body>

</html>